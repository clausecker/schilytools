 \" @(#)smake.1	1.69 21/09/07 Copyright 1985-2021 J. Schilling
 \"                           Copyright 2022 the schilytools team
. \"  Manual page for smake
. \"
.if t .ds a \v'-0.55m'\h'0.00n'\z.\h'0.40n'\z.\v'0.55m'\h'-0.40n'a
.if t .ds o \v'-0.55m'\h'0.00n'\z.\h'0.45n'\z.\v'0.55m'\h'-0.45n'o
.if t .ds u \v'-0.55m'\h'0.00n'\z.\h'0.40n'\z.\v'0.55m'\h'-0.40n'u
.if t .ds A \v'-0.77m'\h'0.25n'\z.\h'0.45n'\z.\v'0.77m'\h'-0.70n'A
.if t .ds O \v'-0.77m'\h'0.25n'\z.\h'0.45n'\z.\v'0.77m'\h'-0.70n'O
.if t .ds U \v'-0.77m'\h'0.30n'\z.\h'0.45n'\z.\v'0.77m'\h'-.75n'U
.if t .ds s \(*b
.if t .ds S SS
.if n .ds a ae
.if n .ds o oe
.if n .ds u ue
.if n .ds s sz
.TH SMAKE 1 "2022/10/06" "J\*org Schilling" "Schily\'s USER COMMANDS"
.SH NAME
smake \- maintain, update, and regenerate programs
.SH SYNOPSIS
.B smake
[
.I options
] [
.BI \-f " makefilename"
] [
.IR target "1\|.\|.\|." target n
]
.PP
.B smake
[
.I options
] [
.BI \-f " makefilename"
]
.B \-V
.IR "macro" "1 [ \.\.\."
.B \-V
.IR "macro" "n ]"
.SH DESCRIPTION
.B Smake
executes command sequences based on relations of modification dates of files.
The command sequences are taken from a set of rules found in a 
.B makefile  
or in the set of implicit rules.
The argument 
.I target 
is typically a program that is to be built from the known rules.
.PP
If no
.B \-f
option is present, 
.B smake
looks for 
.B SMakefile
then for
.B Makefile
and then for
.B makefile 
in the named order.
If in POSIX mode,
.B smake
looks for
.BR makefile , " Makefile"
and then for 
.BR SMakefile .
.PP
If no 
.I target 
is specified on the command line,
.B smake
uses the first regular target that could be found in
.I makefilename 
and that does not start with a dot ('.') letter combination.
.PP
If a 
.I target 
has no explicit entry in the 
.I makefile
.B smake
tries to use implicit rules or the 
.B \&.DEFAULT
rule.
.PP
Unlike most other make programs,
.B smake
propagates all command line macros to sub makes.
This is a big advantage with hierarchical makefile systems.
Propagation is done in a 
.B POSIX
compliant way using the
.B MAKEFLAGS=
environment.
.PP
Unlike other make programs,
.B smake
includes a set of 
.B automake
features that allow one to implement portable, layered, object oriented makefiles.
.PP

.SH OPTIONS
.TP
.B \-a
Do not set up architecture specific make macros like
.BR MAKE_ARCH ,
.B MAKE_OS
and similar that are provided as part of the
.B automake
features.

.TP
.BI \-C " dir"
Change the working directory to
.I dir
before starting work.
.sp
This option may be specified more than once, each subsequent occurrence of the
option is dependent on those that came before it.
.TP
.B \-e
Environment variables override macro definition in Makefile(s).
.TP
.B \-i
Ignore error codes returned by commands that are called from rules.
This is equivalent to having the special target
.B \&.IGNORE
without dependencies inside a makefile.
.TP
.BR "\-j " maxjobs
Specifies the maximum total number of jobs that are run in parallel.
This option is currently ignored.
.TP
.B \-k
Ignore errors by aborting work on the current target and continuing the
work on other targets that do not depend on the failed target.
.TP
.B \-N
Continue if a named dependency does not exist and no related source
could be found. 
.B Smake
by default aborts on this condition, but it seems that traditional UNIX
make programs ignore this condition for unknown reason.
.TP
.B \-n
Don't make \- only say what to do. 
This prints the commands that would be executed on standard output.
Lines with a plus sign ('+') will be executed in any case.
Even those lines that have an at sign ('@') will be printed to standard output.
If a command line contains the macro
.B "$(MAKE)"
or
.B "${MAKE}"
this command line is executed even if there is no plus sign ('+').
.TP
.B \-p
Print the complete set of macro and target definitions on standard output.
.TP
.B \-q
Question mode. Exit code is 0 if the target is up to date. In all other
cases, the exit code is 1.
Lines with a plus sign ('+') will be executed in any case.
.TP
.B \-r
Turn off internal rules.
Do not use the built in rules and do not read the files 
.B \&./defaults.smk
and
.B /opt/schily/share/lib/smake/defaults.smk
.TP
.B \-S
Undo the effect of the \-k option and terminate 
.B smake
if an error occurs while updating targets.
.TP
.B \-s
Be silent. (Do not print command lines or touch messages
on standard output before they are executed.)
This is equivalent to having the special target
.B \&.SILENT
without dependencies inside a makefile.
.TP
.B \-t
Touch objects instead of executing the defined commands.
This brings a target up to date by simply setting the modification
time of the targets instead of performing the their rules.
.B Warning:
This can be dangerous when files are maintained by more than one person.
Targets that do not have a command associated are not touched.
The command lines that are associated with a target are not executed.
Lines with a plus sign ('+') will be executed in any case.
.TP
.BI \-V " macro"
Print the contents of the macro
.B macro
after full expansion. Do not start building any targets except
dependency files. If the macro cannot be found but it contains a
dollar-sign it will be expanded as-is and the result will be printed.
You can specify this option more than once, in this case the results
will be printed on separate lines.
.TP
.B \-w
Don't print warning messages.
.TP
.B \-W
Print extra debug messages and warning messages.
.TP
.B \-WW
Print even more extra debug messages and warning messages.
.TP
.B \-D
Display Makefiles as they are read in.
This allows one to debug the effective
.I makefile
when the makefiles use
.B include 
statements.
.TP
.B \-DD
Display Makefiles and internal rules as they are read in.
This is the same as specifying
.B \-D
but 
.B smake 
starts to print the effective makefile when reading the internal definitions.
If
.B \-DDD
is specified, the printout includes even the 
definitions of the environment variables as make macros.
.TP
.B \-d
Print the reason why a target has to be rebuilt.
Also turns off external and internal silent flag.
This special feature allows one to write makefiles that usually
suppress the printing of commands line (using a '@' at the
start of a command line) as in debug mode
.B smake 
undoes the effect of the '@' character.
.TP
.B \-dd
Print additional debugging messages.
This includes the messages from the \-d flag and additional
messages that allow execution tracing of the various rules.
If more 'd' characters are added (e.g.
.BR \-dddd ") the verbose level for tracing is enhanced."
.TP
.B \-xM
Print the make file include dependency list.
This options allows one to trace complex makefiles that make heavy use
of the 
.B include
statement.
.TP
.B \-xd
Print extended debug messages.
This is only useful, if you have 
internal knowledge to 
.B smake
itself and want to do heavy debugging.
.TP
.B \-probj
Print the whole object tree.
This is only useful, if you have 
internal knowledge to 
.B smake
itself and want to do heavy debugging.
.TP
.B \-help
Prints a short summary of the 
.B smake
options and exists.
.TP
.B \-version
Prints the 
.B smake
version number string and exists.
.TP
.B \-posix
Force
.B smake
to go into POSIX mode.
This is equivalent to having the special target
.B \&.POSIX
inside a makefile.
.RS
.PP
See the description of the special target
.B \&.POSIX
for more information.
.RE
.TP
.BI \-f " makefilename, " mf= "makefilename, " mf= " makefilename"
Specifies the Makefile.
.TP
.I macro=value
Set a macro. A macro definition on command line overrides any other
macro definition.
.PP
Options, command line macros and target name may be intermixed.
.B Smake
will always first evaluate all options then all command line macros and
then will start building the targets.
With 
.B smake
it is not possible to first make one target, then set a command line macro and
then make the next target with different macro values,
.B POSIX 
does not specify the behavior in this case anyway.

.SH OPERANDS
The following operands are supported:
.TP
.I target
any number of target names. The targets are build in the order of occurrence.
.TP
.IB macro = value
A macro definition. Macro definitions from the command line overwrite regular macro
definitions in makefiles or taken from the environment.
.TP
.IB macro ::= value
A macro definition.
The value is expanded before the assignment is done.
This variant of a macro definition creates a different macro type that is not
expanded on use.
.sp
The
.B ::=
operator is only supported when in
.B POSIX
mode.
.TP
.IB macro :::= value
A macro definition.
The value is expanded before the assignment is done.
.TP
.IB macro " +=" value
Append to a macro definition.
.sp
A space is required before
.B +=
and the whole command line macro definition needs to be quoted.
.TP
.IB macro " +:=" value
Append to a macro definition.
The value is expanded before the assignment is done.
.sp
A space is required before
.B +:=
and the whole command line macro definition needs to be quoted.
.PP
All macro definitions are evaluated before any target it build.

.\".SH "Arbeitsweise
.SH BASICS \" Grundlagen
.PP
.B Smake
maintains the dependency of a group of files by building a dependency
tree of the targets (derived files) and the files that are the 
prerequisites of the targets (called the sources or the dependency list
of files).
A 
.I makefile
contains a description of the relations of the targets and the prerequisites
and the commands that should be executed to make the target up to date.
.PP
.nf
.B
	foo : main.o lex.o parse.o 
.B
	main.o: main.c main.h
.fi
.PP
The file 
.B foo
depends on the files
.B main.o lex.o
and
.B parse.o
while
.B main.o 
depends on
.B main.c
and 
.BR main.h .
This example describes a project in the C-programming language,
but it is possible to maintain any project that depends on the modification
time of the related files.
.PP
.B Smake
considers a file up to date if it has been modified after the files
it depends on (its prerequisites) and all files it depends on are recursively up
to date too.
If a file does not exit, it is considered to be out of date.
The targets are processed in the order they appear in the dependency list.
.PP
For example, if 
.B main.o
is newer than 
.BR foo ,
then it is assumed that 
.B foo
is not up to date.
If 
.B main.c
is newer than 
.BR main.o, 
then it is assumed that both,
.B main.o
and
.B foo
are not up to date.
.PP
.B Smake
updates all targets based on 
.BR rules .
A 
.B rule
specifies a target and its prerequisites and defines a set of commands
that allow one to create an up to date target from its prerequisites.
.PP
If the target and its prerequisites are named explicitly, the rule
is called an 
.BR "explicit rule" . 
If the target and its prerequisites are named in an abstract way, the rule
is called an 
.B "implicit rule" 
or an
.BR "inference rule" .
.PP
If 
.B smake 
is called to update a target, it first checks if an explicit rule for this
target can be found. If there is no explicit rule for this target, then
.B smake
looks for an implicit rule. It checks the following methods of
specifying an implicit rule until a suitable rule is found.
Each method is described in section
.B "Makefile Format"
below or in the section
.BR "Implicit Rules" .
.
.TP
\(bu
Pattern matching rules from a user supplied makefile.
.TP
\(bu
Suffix rules,
either from a user supplied makefile or from the
set of builtin rules.
.TP
\(bu
Simple suffix rules,
either from a user supplied makefile or from the
set of builtin rules.
.TP
\(bu
.B SCCS
retrieval.
If 
.B smake
finds a more recent 
.B SCCS
history file, it tries to retrieve the most recent version
from the
.B SCCS
history. See the description of the
.B \&.SCCS_GET
special target.
.TP
\(bu
The rule from the
.B \&.DEFAULT
target entry, if such an entry exists in a makefile.
.PP
A limited set of built in rules is compiled into
.BR smake .
A more complete set is read from the file
.B \&./defaults.smk
or
.BR /opt/schily/share/lib/smake/defaults.smk .

.SH "Makefile Format"
.PP
.B
Smake
reads its rules from a file named
.BR SMakefile , " Makefile"
or 
.B makefile
in the current directory and checks for the files in the named order. 
If in POSIX mode,
.B smake
looks for
.BR makefile , " Makefile"
and then for
.BR SMakefile .
If a different makefile is specified with the
.B \-f
option, 
.B smake 
reads from this file.
In case that no makefile was specified with the 
.B \-f
option, it is not an error if no makefile exists.
In this case
.B smake
only uses the built in rules.
The term 
.I makefile
is used for any user supplied file that contains rules for the
.B make
utility.
.PP
A 
.B makefile 
contains rules, macro definitions, special make directives and comments.
A rule may either be a target rule (explicit rule) or an implicit rule.
.B Smake
itself contains or loads a number of built in implicit rules which are not used
if the 
.B \-r 
option is used. The user specified 
.I makefile
defines additional explicit and implicit rules and macros.
If a macro is defined more than once, the last definition is used.
If a target rule is defined more than once, the dependency list is the
sum of all dependency lists and the set of commands is the 
set of commands from the last specification.
A back slash ('\e') at the end of a line indicates that this line
is to be continued on the next line.
An escaped newline is replaced by a single space character
and the white space at the beginning of the next line is removed.
A comment starts with a hash mark ('#') and ends if an un-escaped
new line is found.

.SS "Command Execution"
.PP
Command lines associated with rules are sequentially executed line by line
in an own process or shell.
All commands may use constructs supported by the standard shell
.RB ( /bin/sh ).
POSIX shell constructs are permitted
as long as the local shell supports them.
Command lines may have prefixes that are interpreted by 
.B smake
before the rest of the command line is executed or passed to the shell.
All characters from the list below that immediately follow the TAB character
are interpreted by
.BR smake .
The first non-blank
character that is not from the list below is the first character
passed to the shell.
The following
prefixes are implemented:
.TP
.B \-
If the character '-' is amongst the prefix characters or of the 
.B \-i
option has been specified or the special target
.B \&.IGNORE
has been specified with no dependencies or with the current
target in the list of dependencies, the exit code
from the command line is ignored.
.TP
.B +
If the character '+' is amongst the prefix characters, the command line
is executed even if one of the options
.BR \-n ", " \-q " or " \-t
was specified.
.TP
.B @
If the character '@' is amongst the prefix characters or of the
.B \-s
option has been specified or the special target
.B \&.SILENT
has been specified with no dependencies or with the current
target in the list of dependencies, the command line
is not printed before it is executed.
.TP
.B ?
Reserved for future use (currently ignored).
.TP
.B !
Reserved for future use (currently ignored).
.PP
Typical UNIX systems are fast with calling the shell.
Some operating systems (like e.g. win32) however are slow with creating
processes. As calling a command via the shell results in 
creating an additional process, command execution via the shell causes 
unneeded overhead for simple commands.
To speed up command execution, 
.B smake
tries to avoid calling commands via the shell when no shell meta character
appears on the commandline.
As commandlines used in makefiles frequently look like:
.PP
.RI	@echo " message; " "cc .\&.\&."
.PP
.B smake
avoids to call a shell in such cases by executing simple 
.B echo
commands inline in case they are at the beginning of a command.
A simple
.B echo
command is a command without I/O redirection and without shell variable expansion.
.PP
If the environment
.B FORCE_SHELL
is present or the special target
.B \&.FORCE_SHELL:
has been defined, 
.B smake
does not try to optimize command execution and calls all commands via the shell.
If the
.B SHELL 
special macro is used to define an alternate shell that is based on a different
set of shell meta characters than the meta characters used by the POSIX shell:
.sp
	\fB# | = ^ ( ) ; & < > * ? [ ] : $ ` ' " \e \en\fR \" " <--- hack for nroff-mode. please keep.
.sp
it is recommended to define the special target
.B \&.FORCE_SHELL:
in addition.


.SS "Target rules"
.PP
A target rule looks this way:
.PP
.ne 3
.RS
.HP
.IR target " .\|.\|."
.RB [ : \||\| :: ]
.RI [ dependency "] .\|.\|."
.RB [ ;
.IR command "] .\|.\|."
.nf
.RI "[<tab> " command ]
\&\|.\|.\|.
.fi
.RE
.PP
The first line may not start with a TAB character. 
It starts with a 
.I target name 
or a white space separated list of 
.IR "target names" ,
in both cases followed by colon as a target separator
(':') or by a double colon ('::').
The colon may be followed by a 
.I dependency name 
or a white space 
separated list of 
.IR "dependency names" .
The double colon allows one to specify alternate dependency lists and
commands for the same target.
The dependency list may be followed by a semicolon (';') and a
Bourne shell
.IR command .
There may be additional lines with Bourne shell commands, all
starting with a TAB. The first line that does not start with a TAB
starts another definition.
.PP
Bourne shell commands may be continued over more than one line if
the new line is escaped with a back slash. The next line must also
start with a TAB character.

.SS "Make directives"
.PP
.TP
.BI export " macro .\|.\|."
The list of macros that follows the
.B export
directive is exported in the list of environment variables.
If an environment variable with the same name already exists,
it's value is replaced by the current value of the related make macro.
An empty list of macro names is not considered an error.
If the 
.B PATH
macro is in the list of parameters, the path search of the current
.B smake
process is also affected.
If the 
.B SHELL
macro is in the list of parameters, it is ignored and the
previous 
.B SHELL
environment is kept.
.TP
.BI include " filename .\|.\|."
Reading and parsing makefiles is temporarily continued with the list of 
the file name parameters to the
.B include
directive.
If one or more file names from the parameter list contains make macro expressions, 
the macro expressions are evaluated before the file names are used.
A single make macro may contain a list of include file names.
If 
.B smake
knows rules to 
.B make
the files to include,
.B smake
will evaluate the related rules before doing the include.
Include directives may be nested as long as there are unused file descriptors.
An empty list of filenames is not considered an error.
If one or more files from the parameter list do not exist, 
.B smake
aborts.
.TP
.BI \-include " filename .\|.\|."
The
.B \-include
directive is implemented similar to the
.B include
directive, except that a nonexistent file is not considered to be an error.
.TP
.BI readonly " macro .\|.\|."
Mark the list of macros in the parameter list as
.BR readonly .
This prevents further modification of the content of the related macros.
An empty list of macro names is not considered an error.
.TP
.BI unexport " macro .\|.\|."
The list of macros that follows the
.B unexport
directive is removed from the list of environment variables.
An empty list of macro names is not considered an error.
If the 
.B PATH
macro is in the list of parameters, the path search of the current
.B smake
process is also affected.
If the 
.B SHELL
macro is in the list of parameters, it is ignored and the
previous 
.B SHELL
environment is kept.

.SH "Automake Features"
.PP
.B Smake
implements
.B automake
features that help to write highly portable makefile systems. The
.B automake
features are implemented with a set of special purpose macros and by special
rules that help to extend the functionality and automated adaptivity of
.BR smake .
.SS "Automake special purpose macros"
.PP
The special purpose macros that have names that match
.B "MAKE_*"
(see section
.BR "Special Macros" )
are part of the
.B automake
features of smake.
The related special macros are set up by 
.B smake
to contain values that have been retrieved from the results of the
.BR uname (2),
.BR sysinfo (2)
or
.BR sysctl (2)
system calls.
The values for these macros may however be overwritten from a makefile
or from a command line macro definition.
.SS "Automake special targets"
.PP
The special target
.B \&.INCLUDE_FAILED
allows one to define a rule that is evaluated in case that an include
file does not exist and could not be made from other rules.
As the associated command for this target is typically a shell script,
the shell script can be written to create fall back rules in a platform
independent way.

.SH "Search Rules For Files"
.PP
In many cases, it is desirable to hold object files in a special
directory which is different from the directory where the source
files are located.
For this reason, 
.B smake
allows one to specify a directory where all targets are placed in case they are
a result of an implicit rule.
Add 
.PP
.BI \&.OBJDIR: "	object_directory"
.PP
to the 
.B makefile
to activate this 
.B smake 
feature.
If a 
.B makefile
uses this feature, it must either explicitly use the right
file names (including the object directory) or use dynamic macros 
that are automatically updated to include the path of the
object directory.
If
.B smake
uses file name searching, the dynamic macros
.BR "$<" ", " "$0" ", " "$\fIn\fP" ", " "$r1" ", " $^ ", and " "$?"
are updated to reflect the
actual path of the source or object directory.
.
.PP
A line of the form:
.PP
.BI \&.SEARCHLIST: "	source_directory_1 object_directory_1"
\&.\|.\|.
.PP
that contains pairs of source and corresponding object directory
names, will cause
.B smake
not only to search for files in the current directory and in
the directory which is pointed to by
.BR \&.OBJDIR ,
but also in the directories from
.BR \&.SEARCHLIST: .
.B Smake
first looks in the current directory, then in the directory pointed to
by
.B \&.OBJDIR
and then in the directories from
.BR \&.SEARCHLIST: .
.PP
If a source could be found in a specific source directory of the
list of source and object directories,
the targets will only be looked for in the corresponding object 
directory.
A result of a source, which is found in any of the
source-directories of the
.B \&.SEARCHLIST:
is placed into the
corresponding object-directory.
.PP
A line in the form:
.PP
.BI \&.OBJSEARCH: 	value
.PP
Where
.I value
may be one of
.I src, obj, all.
causes
.B smake
to look for left-hand-sides of rules in only the
.B source-directories,
the
.B object-directories
or 
.BR both .
The default value for
.B \&.OBJSEARCH:
is:
.BR all .
That causes
.B smake
to search for results in object-directories and source-directories.
.PP
If no 
.B \&.SEARCHLIST
target exists, but a
.B VPATH=
macro is found, 
.B smake
transforms the content of the
.B VPATH=
macro into a form suitable for 
.BR \&.SEARCHLIST: .
This is done by putting each 
.B VPATH=
entry twice into the
.BR \&.SEARCHLIST: .
Please report problems with this solution.

.br
.ne 10
.SH Macros
.SS "Macro Definitions"
Macros are defined by a line in the form:
.PP
.BI macroname= "	value"
.PP
The
.I value
assigned to the macro contains all characters after the equal sign
up to a comment character ('#') or an unescaped newline. Any blank characters that
directly follow the equal sign are ignored.
.PP
An alternate macro definitions uses the form:
.PP
.BI "macroname +=" "	value"
.PP
to append
.I value
to the current definition for
.BR macroname .
.sp
Note that there needs to be white space before the '+=' as
.B smake
allows macro names like
.BR C++ .
.sp
Warning: Macros created with the
.B ::=
operator will cause the
.B +=
operator to evaluate macros on the right side of the operator
before doing the actual append operation.
To avoid unpredictable behavior, it is recommended to use at least one
lower case character in the name of macros that have been created using
the
.B ::=
operator.
.PP
An alternate macro definitions uses the form:
.PP
.BI "macroname +:=" "	value"
.PP
to append
.I value
to the current definition for
.B macroname
after
.I value
has been evaluated.
The string
.B $$
is not expanded with the 
.B +:=
operator, it is left unmodified while the right side is expanded.
.sp
Note that there needs to be white space before the '+=' as
.B smake
allows macro names like
.BR C++ .
.PP
A macro definition that uses the form:
.PP
.BI "macroname ?=" "	value"
.PP
will assign 
.I value
to the current definition for
.B macroname
in case that
.B macroname
does not yet have a definition.
.PP
A macro definition that uses the form:
.PP
.BI macroname:= "	value"
.PP
will evaluate the right side of the assignment when the line is read by the
parser.
.sp
The
.B :=
operator has been introduced in 2005 as a temporary feature.
It currently is an alias to the final
.B :::=
operator explained below.
.sp
Note that SunPro make was the first make implementation that introduced
.B := 
in 1986 already, but for a different incompatible purpose,
GNU make in 1990 introduced
.B :=
with a another different incompatible purpose that later has been standardized
by POSIX issue 8 as the
.B ::=
operator.
BSD make implements the same behavior as
.B smake
for the
.B :=
assignment operator.
A makefile that uses 
.B :=
thus is non-portable for use with different make implementations.
.B smake
may change its behavior in the future and implement a
.B SunPro Make
compatible conditional macro assignment instead of the current behavior for
.BR := .
For this reason, it is recommended to use
.B :::=
instead of
.BR := .
.br
.ne 9
.PP
A macro definition that uses the form:
.PP
.BI "macroname ::=" "	value"
.PP
will evaluate the right side of the assignment when the line is read by the
parser.
.sp
Macros created with this operator are not expanded on use.
.sp
Note that this is the POSIX variant of the GNU immediate assignment that is
portable to
.B make
implementations that are compatible to POSIX issue 8 and used in POSIX mode.
.sp
The
.B ::=
operator is only supported by
.B smake
when in
.B POSIX
mode.
.sp
Warning: This operator may cause unpredictable behavior, since it creates a
different type of macro that is not expanded on use and that causes a different
behavior with the
.B +=
operator.
In order to avoid the unpredictable behavior with the
.B +=
operator, it is recommended to avoid the
.B ::=
operator in favor of
.BR :::= ,
or to use at least one lower case letter as a marker in the names of all macros
that have been created with the
.B ::=
operator.
.PP
A macro definition that uses the form:
.PP
.BI "macroname :::=" "	value"
.PP
will evaluate the right side of the assignment when the line is read by the
parser.
The string
.B $$
is not expanded with the 
.B :::=
operator, it is left unmodified while the right side is expanded.
Note that this is a naming for the immediate expansion assignment operator
that is usable in portable makefiles with make implementations compatible
to POSIX issue 8.
The operator
.B :::=
should be used in favor of
.B :=
and
.B ::=
for all new makefiles.
.PP
A macro definition that uses the form:
.PP
.BI macroname:sh= "	command"
.PP
will call
.I command
and define the macro value to be the output of
.I command
when the line is read by the parser.
.SS "Macro References"
.PP
Macros may be referenced by either: 
.BI $( macroname )
or
.BI ${ macroname }.
The parentheses or braces are optional for a macro with a single character name.
.PP
Macro definitions and macro references can appear anywhere in the makefile. Macro
references are expanded under the following circumstances:
.TP
\(bu
Macros in target lines are evaluated when the target line is read by the parser.
.TP
\(bu
Macros in command lines for rules are evaluated when the command is executed.
.TP
\(bu
Macros in the string before ':', '::', '=' or '+=' (names for target or macro 
definitions)
are evaluated when the target line is read by the parser.
.TP
\(bu
Macro references after the equal sign in a macro definition are not evaluated
until the defined macro itself is used in a rule or a command or to the left of
the equal sign from a macro definition.
.SS "Macro Substitution"
.PP
Macro references may be used to substitute macro values.
There are different methods for macro substitution.
.SS "Suffix Replacement Macro References"
.PP
A macro reference in the following form:
.PP
.B
	$(\fIname\fP:\fIsubst1\fP=\fIsubst2\fP)
.PP
is used to replace the suffix or word
.B subst1
in the value of the macro
.B name
by
.BR subst2 .
Words are separated by space or tab characters.

.SS "Pattern Replacement Macro References"
.PP
A macro reference in the following form:
.PP
.B
	$(\fIname\fP:\fIop\fP%\fIos\fP=\fInp\fP%\fIns\fP)
.PP
is used to replace prefixes and suffixes in words. In this case,
.I op
is the old prefix,
.I os
is the old suffix,
.I np
is the new prefix
and
.I ns
is the new suffix.
The strings
.IR op ,
.IR os ,
.I np
and
.I ns
may all be empty strings.
The pattern % matches a string of zero or more characters.
The matched pattern is carried forward to the replacement target.
For example:
.PP
.B OBJECT=foo.o
.br
.B SCCS_HISTFILE=$(OBJECT:%.o=SCCS/s.%.c)
.PP
replaces 
.B foo.o 
by 
.B SCCS/s.foo.c
when the macro
.B $(SCCS_HISTFILE)
is referenced.
.LP
The replacement is done on a word by word base and the white space between words
is literally retained. If there is no match, the result is unmodified.
.SS "Shell Replacement Macro References"
.PP
A macro reference in the following form:
.PP
.B
	$(\fIname\fP:sh)
.PP
will interpret the content of the macro
.I name
as a shell command line, call the shell with the content of the macro
and return the output of the called command.

.SH "Special Targets"
.\".TP
.\".B \&.AR_REPLACE
.\"This target can be used to specify a rule to preprocess
.\"member files before updating an
.\".BR ar (1)
.\"library.
.TP
.B \&.DEFAULT:
If a 
.I target 
is considered to be out of date and no other rule applies to this
target, 
.B smake
executes the commands from this special target.
The
.B \&.DEFAULT
target may not have a dependency list.
.TP
.B \&.DONE:
If this special target is present, 
.B smake
executes the commands after all targets have been processed.
The
.B \&.DONE
target is also executed if a failure occurs and no
.B \&.FAILED
target is present.
The
.B \&.DONE
target may not have a dependency list.
.TP
.B \&.FAILED:
If this special target is present and an error occurred,
.B smake
executes the commands instead of the the commands of the
.B \&.DONE
target after all targets have been processed.
The
.B \&.FAILED
target may not have a dependency list.
.TP
.B \&.FORCE_SHELL:
If this special target is present,
.B smake
executes all commands via the shell instead of trying to optimize command
execution for simple commands.
.TP
.B \&.GET_POSIX:
Reserved for future use.
.\"This target contains the rule for retrieving the current version of an
.\".SM SCCS
.\"file from its history file in the current working directory.
.\".B smake
.\"uses this rule when it is running in
.\".SM POSIX
.\"mode.
.TP
.B \&.IGNORE:
Ignore errors.
When this special target is present and has no dependencies, 
.B smake
will ignore errors from commands.
Specifying
.B \&.IGNORE:
without dependencies is equivalent to using the
.B \-i
option.
If
.B \&.IGNORE:
has dependencies and the current target is in the list of dependencies
of
.B \&.IGNORE:
the exit code for the related commands is ignored.
.TP
.B \&.INCLUDE_FAILED:
This special target implements
.B automake
features for object oriented layered makefiles.
If this target is present and defines commands, 
.B smake
executes the commands for this target
in case that a makefile could not be included and there
was no other explicit or implicit rule that did create the the missing
make include file.
.sp
The
.B \&.INCLUDE_FAILED
target may not have a dependency list.
When the
.B commands
for the target
.B \&.INCLUDE_FAILED
are called, the dependency list of the special target is set up to
the include filename that caused the failure.
It is therefore recommended to define the
.B commands
for the
.B \&.INCLUDE_FAILED
target to include
.B $^
as parameter.
The commands for the target
.B \&.INCLUDE_FAILED
are called only for the
.B include
and not for the
.B \-include
directive. If the commands for the
.B \&.INCLUDE_FAILED
target cannot create a file that is going to be included,
.B smake
fails.
.TP
.B \&.INIT:
If this target is present, the target and its dependencies are built before
any other target is made.
.TP
.B \&.KEEP_STATE:
Reserved by SunPRO make. Don't use this target to avoid problems with
the SCHILY (Sing) makefile system.
.TP
.B \&.KEEP_STATE_FILE:
Reserved by SunPRO make. Don't use this target to avoid problems with
the SCHILY (Sing) makefile system.
.TP
.B \&.MAKE_VERSION:
Reserved for future use. Future versions of 
.B smake
may implement this special target in a way similar to SunPRO make.
.sp
A special target of the form:
.RS
.IP
.BI \s-1.MAKE_VERSION:\s0\0\0\s-1smake\-\s0 number
.RE
.IP
forces to check the version of
.BR smake .
If the version of
.B smake
differs from the version in the dependency list,
.B smake
issues a warning message.
The actual version of 
.B smake 
is
.I smake-1.0
.TP
.B \&.NO_PARALLEL:
Reserved for future use.
.TP
.B \&.NO_WARN:
If this special target is present and has a dependency list, special
warnings may be disabled depending on the names used in the pseudo
dependency list.
.sp
If
.B \&.NO_WARN:
does not have any dependencies, the list of warning exceptions is
cleared.
.sp
The following pseudo dependencies are implemented:
.RS
.TP
.B :=
Suppress warnings about nonportable ':=' macro assignments.
.TP
.B $$*
Suppress warnings for using the dynamic macro '$*' in explicit rules.
.TP
.B $$<
Suppress warnings for using the dynamic macro '$<' in explicit rules.
.RE
.TP
.B \&.OBJDIR:
If this special target is present, 
.B smake 
assumes that all files that have been created by a rule should be
placed in a special directory called the object directory.
The object directory is the only member of the dependency list
of the 
.B \&.OBJDIR
target.
.B Smake
moves the targets automatically into that directory.
Automatic macros like $^, $?, $r1 are automatically modified in
a way that allows transparent use of the object directory.
If 
.B \&.OBJDIR:
is not specified, it is assumed to be the current directory '.'.
.TP
.B \&.OBJSEARCH:
This target may hold one of three predefined values:
.BR src ", " obj " and " all .
It defines where objects (targets of a rule) are searched for.
The default for
.B \&.OBJSEARCH:
is to look for targets in both
(source and object) directories or directory lists.
See also
.B \&.SEARCHLIST
for a description of the src and obj directories.
.TP
.B \&.PARALLEL:
Reserved for future use.
.TP
.B \&.POSIX:
If this special target is found, POSIX mode is enabled.
.RS
.PP
With this option the verbose command lines written to the
.I stdout
stream are prefixed by a TAB character instead of three dots (...).
I POSIX mode,
.B smake
also calls commands via
.B "/bin/sh \-c 'cmd'"
instead of
.BR "/bin/sh \-ce 'cmd'" .
This causes 
.B smake
not to stop at failing sub commands in complex commands. If the 
.B \&.POSIX:
special target is used, it is highly recommended to also specify
.B "MAKE_SHELL_FLAG=\-ce"
to make sure that the make process still stops at failed commands.
.RE
.TP
.B \&.PRECIOUS:
This macro holds a list of targets that should not be removed while they 
are built if
.B smake
receives a signal.
If the list is empty, this applies to all targets.
.TP
.B \&.PHONY:
This macro holds a list of targets that should not be checked against existing
files. A target that is marked
.B \&.PHONY
will always considered to be out of date. If
.B smake
receives a signal, targets marked as
.B \&.PHONY
are not removed.
If 
.B smake
is called with the
.B \-t
(touch) option, the targets marked as
.B \&.PHONY
are not touched.
.TP
.B \&.SCCS_GET:
Reserved for future use.
.TP
.B \&.SCCS_GET_POSIX:
Reserved for future use.
.\"This target contains the rule for retrieving the current version of an
.\".SM SCCS
.\"file from its history file.
.\".B smake
.\"uses this rule when it is running in POSIX mode.
.TP
.B \&.SEARCHLIST:
.B \&.SEARCHLIST
is a list of alternate source and object directories
where 
.B smake
should look for targets.
This macro may be used as an extended replacement of the 
.B VPATH=
macro of other make programs.
The macro 
.B \&.SEARCHLIST
holds a list of 
.I srcdir " / " objdir
pairs. 
The complete internal list is build from '.'
.B \&.OBJDIR
and the content of
.BR \&.SEARCHLIST .
.TP
.B \&.SILENT:
Run silently.
When this special target is present and has no dependencies, 
.B smake
will not echo commands before executing them.
Specifying
.B \&.SILENT:
without dependencies is equivalent to using the
.B \-s
option.
If
.B \&.SILENT:
has dependencies and the current target is in the list of dependencies
of
.B \&.SILENT:
the related commands are not echoed before they are executed.
.TP
.B \&.SPACE_IN_NAMES:
If this target is present and has a dependency list, escaped
spaces may occur in object and dependency names. If
.B \&.SPACE_IN_NAMES:
is not followed by any dependency, the previous dependencies are cleared
and make file parsing is done again in a
.B POSIX
compliant way.
The following code fragment allows one to use non standard space handling
for one target only:
.sp
.ne 7
.RS
.BR \&.SPACE_IN_NAMES: " true"
.sp
.B "target\e with\e spaces: dependency\e with\e spaces"
.br
.B "	command list"
.sp
.B \&.SPACE_IN_NAMES:
.br
.RE
.TP
.B \&.SSUFFIX_RULES:
If this special macro is present with no dependencies, all current
.B Simple Suffix Rules
are cleared.
.TP
.B \&.SUFFIXES:
Dependencies of
.B \&.SUFFIXES
are appended to the list of known suffixes and are used in conjunction with
the suffix rules (see
.BR "Suffix Rules" ).
If
.B \&.SUFFIXES
does not have any dependencies, the list of known suffixes is cleared.
If the list of
.B \&.SUFFIXES
was cleared, no implicit suffix rule search is done.
.TP
.B \&.SYM_LINK_TO:
Reserved for future use.
.TP
.B \&.WAIT:
Reserved for future use.

.SH "Special Macros"
.TP
.B CURDIR
After
.B smake
has processed all
.B \-C 
options (if any), it sets the variable
.I CURDIR
to the absolute pathname of the current working directory.
This value is never touched by
.B smake 
again.
An environment variable will not overwrite it, but a makefile may.
Setting this variable has no effect on the operation of
.BR smake .
.TP
.B MAKE
This macro contains a path name that is sufficient to recursively
call the same
.I make
program again (it either contains the last path component or the full path
name of the make program).
Note that this may differ from the name that was used on the command line
if the name that was used on the command line would not allow one to call
the same
.I make 
program from a different directory using this name.
For this reason 
.I $(MAKE)
may not be used to check for a specific 
.I make 
program. Use
.B $(MAKE_NAME)
instead.
If a command line contains this macro,
this command line is executed even if there is no plus sign ('+').
.
.TP
.B MAKEFLAGS
This macro contains the command line flags and the command line macros
.B smake
is called with.
The 
.B MAKEFLAGS
macro is exported into the environment to allow automatic propagation of 
.I make
flags and command line macros to sub make programs.
The content of this macro is
.B POSIX
compliant.
.sp
If there were no command line flags or command line macros, the
.B MAKEFLAGS
macro is empty.
.sp
If there were only command line flags, the
.B MAKEFLAGS
macro contains a concatenation of the single char versions of the
flags. A hyphen is the first char, so
.B MAKEFLAGS
would be suitable as a command line flag in this case.
A typical
content may look this way: 
.br
.BR "\-id" .
.sp
If there were only command line macros, the
.B MAKEFLAGS
macro contains a concatenation of the macro specifications.
The different macro specifications are separated by a space.
Any occurrence of a space or a back slash inside a macro specification
is escaped by a back slash.
A typical
content may look this way:
.br 
.BR "CC=gcc COPTX=\-DTEST\e \-DDEBUG" .
.sp
If both command line flags and command line macros are used, the
flag part is made as if there were only flags and the macro part
is made as if there were only macros.
The separator between the flag part and the macro part is a space,
two hyphens and a space.
A typical
content may look this way:
.br 
.BR "\-id -\|- CC=gcc COPTX=\-DTEST\e \-DDEBUG" .
.sp
As the 
.B MAKEFLAGS
notation of the command line macros uses a special escape notation
to allow propagation of any possible command line macro, it is not
possible to call: 
.br
.B make $(MAKEFLAGS)
from a make file.
.
.TP
.B MAKE_MACS
This macro contains the complete set of command line macros and the
macros read from the
.B MAKEFLAGS
environment.
The content is the same as the last part of the
.B MAKEFLAGS
macro which holds the macro part.
The 
.B MAKE_MACS
macro is exported into the environment.
.
.TP
.B MAKE_FLAGS
This macro contains the command line flags
.B smake
is called with.
The content is the same as the content of the
.B MAKEFLAGS
macro except that no command line macros are added.
The 
.B MAKE_FLAGS
macro is exported into the environment.
.
.TP
.B MAKE_ARCH
This macro is set up by 
.B smake
as part of the 
.B automake
features of
.BR smake .
It contains the processor architecture of the current machine
from
.B uname \-p
(e.g. mc68020, sparc, pentium, i386).
.
.TP
.B MAKE_BRAND
This macro is set up by 
.B smake
as part of the 
.B automake
features of
.BR smake .
It contains the brand of the current machine
from
.BR sysinfo (SI_HW_PROVIDER)
(e.g. Sun_Microsystems).
.
.TP
.B MAKE_DOMAIN
This macro is set up by 
.B smake
as part of the 
.B automake
features of
.BR smake .
It contains the domainname of the current machine
from
.BR domainname (1)
(e.g. acme.com).
.
.TP
.B MAKE_HOST
This macro is set up by 
.B smake
as part of the 
.B automake
features of
.BR smake .
It contains the host name of the current machine
from
.B uname \-n
(e.g. duffy, sherwood, ghost).
.
.TP
.B MAKE_HOST_OS
This macro is set up by 
.B smake
as part of the 
.B automake
features of
.BR smake .
It contains the host OS name from
.B uname \-Hs
of the current machine in case that there
is a layered OS like Cygwin (e.g. windows).
.
.TP
.B MAKE_HOST_OSREL
This macro is set up by 
.B smake
as part of the 
.B automake
features of
.BR smake .
It contains the host OS release from
.B uname \-Hr
of the current machine in case that there
is a layered OS like Cygwin (e.g. 5.1).
.
.TP
.B MAKE_HOST_OSVERSION
This macro is set up by 
.B smake
as part of the 
.B automake
features of
.BR smake .
It contains the host OS version from
.B uname \-Hv
of the current machine in case that there
is a layered OS like Cygwin (e.g. sp2).
.
.TP
.B MAKE_HWSERIAL
This macro is set up by 
.B smake
as part of the 
.B automake
features of
.BR smake .
It contains the serial number of the current machine
(e.g. 1920098175).
.
.TP
.B MAKE_ISALIST
This macro is set up by 
.B smake
as part of the 
.B automake
features of
.BR smake .
It contains the instruction set architecture list of the current machine
from
.BR sysinfo (SI_ISALIST)
(e.g. amd64 pentium_pro+mmx pentium_pro pentium+mmx pentium i486 i386 i86).
.
.TP
.B MAKE_M_ARCH
This macro is set up by 
.B smake
as part of the 
.B automake
features of
.BR smake .
It contains the machine architecture of the current machine
derived from
.B MAKE_MACH
(e.g. sun3, sun4).
.
.TP
.B MAKE_MACH
This macro is set up by 
.B smake
as part of the 
.B automake
features of
.BR smake .
It contains the kernel architecture of the current machine
from
.B uname \-m
(e.g. sun3, sun4c, sun4m, sun4u, i86pc).
.
.TP
.B MAKE_MODEL
This macro is set up by 
.B smake
as part of the 
.B automake
features of
.BR smake .
It contains the model name of the current machine
from
.BR sysinfo (SI_PLATFORM)
or
.B uname \-i
(e.g. SUNW,SPARCstation-20).
.
.TP
.B MAKE_NAME
This macro is set up by 
.B smake
as part of the 
.B automake
features of
.BR smake .
It contains the official name of the
make program \- in our case 
.BR smake .
.
.TP
.B MAKE_OS
This macro is set up by 
.B smake
as part of the 
.B automake
features of
.BR smake .
It contains the operating system name of the current machine
from
.B uname \-s
(e.g. sunos, linux, dgux).
.
.TP
.B MAKE_OSDEFS
This macro is set up by 
.B smake
as part of the 
.B automake
features of
.BR smake .
It contains operating system specific defines for the compiler
(e.g. \-D__SVR4).
.
.TP
.B MAKE_OSREL
This macro is set up by 
.B smake
as part of the 
.B automake
features of
.BR smake .
It contains the operating system release name of the current machine
from
.B uname \-r
(e.g. 5.5, 4.1.1).
.
.TP
.B MAKE_OSVERSION
This macro is set up by 
.B smake
as part of the 
.B automake
features of
.BR smake .
It contains the operating system version of the current machine
from
.B uname \-v
(e.g. generic).
.
.TP
.B MAKE_SHELL_FLAG
This macro contains the shell flags used when calling commands from
.BR smake .
The default value is
.BR \-ce ,
When 
.B smake
in in POSIX mode,
the default value is
.BR \-c.
The
.B MAKE_SHELL_FLAG
macro allows one to overwrite the default behavior.
.
.TP
.B MAKE_SHELL_IFLAG
This macro contains the shell flags used when calling commands from
.BR "smake \-i" .
The default value is
.BR \-c .
The
.B MAKE_SHELL_IFLAG
macro allows one to overwrite the default behavior.
.
.TP
.B MAKE_VERSION
This macro contains the 
.B smake
version number string.
.
.TP
.B NUMBER_SIGN
This macro is predefined to contain the number sign ('#') that is used as
the make comment start character and for this reason cannot be appear
in non comment parts of regular makefiles.
.
.TP
.B SHELL
.
The 
.B SHELL
macro is neither imported nor exported from/to the environment.
If it is set from within a makefile or from the commandline, the
value is used as the name of an alternate shell to execute commands.
Makefiles that set 
.B SHELL=
should be used very carefully as not all platforms support all shells.
.TP
.B VPATH
This macro implements some object search functionality as found in 
other UNIX make programs. In 
.B smake
this functionality is implemented using the
.B \&.SEARCHLIST:
special target, see chapter
.B "Search Rules For Files"
for more information.

.SH "Dynamic Macros"
.PP
There are several internal macros that are updated dynamically.
Except 
.BR $O ,
they cannot be overwritten. Using them in explicit rules makes the
makefile more consistent as the file names do not have to be typed
in a second time.
Using them in implicit rules is the only way to make
implicit rules work as the actual file name cannot be coded into
an implicit rule.
.PP
If
.B smake
uses file name searching, the dynamic macros
.BR "$<" ", " "$0" ", " "$\fIn\fP" ", " "$r1" ", " $^ ", and " "$?"
are updated to reflect the
actual path of the source or object directory.
.PP
The dynamic macros are:
.TP
.B $O
expands to the value of
.RB \&.OBJDIR .
If 
.B \&.OBJDIR
is not defined, 
.B $O
expands to '.'.
If
.B $O
has been overwritten, it may no longer be used as a reliable
alias for
.BR \&.OBJDIR .
.TP
.B $@
expands to the path name of the current target.
It is expanded for both explicit and implicit rules.
.TP
.B $*
expands to the path base name of the current target (the
name of the current target with the suffix stripped off).
It is expanded for both explicit and implicit rules.
.B POSIX
requires that this macro is expanded at least for implicit rules.
.TP
.B $<
expands to the path name of implicit source made in this step.
It is expanded for implicit rules only.
The existence of this macro is required by 
.BR POSIX .
.TP
.B $0
expands to the path name of implicit source made in this step.
It is expanded for implicit rules only.
This macro is available with
.B smake
only. It is made available to make the behavior more orthogonal.
.TP
.B $1 $2 $3 ...
expands to the path name of the nth file in the dependency list.
It is expanded for explicit rules only.

.TP
.BI $r n
expands to the path names of all files in the dependency list
starting with the 
.IR n th.
It is valid to specify
.BR $r0 .
It is expanded for both explicit and implicit rules.
The 0th entry is available only with implicit rules, the other
entries are available only with explicit rules.
.TP
.B "$^"
expands to the path names of all files in the dependency list.
With implicit rules, it is identical to
.BR $r0 ,
with explicit rules, it is identical to
.BR $r1 .
.TP
.B "$?"
expands to the path names of all files that are newer than the current target.
It is expanded for both explicit and implicit rules.
.PP
The following example shows how dynamic macros may be used together with
file searching rules:
.PP
.nf
.B
	foo : main.o lex.o parse.o 
.B
		$(CC) \-o $@ $^
.fi
.PP
may expand to:
.PP
cc \-o foo OBJ/main.o parser/OBJ/lex.o parser/OBJ/parse.o

.SH "Implicit Rules"
.PP
If there is no explicit target rule for a specific target,
.B smake
tries to find a matching implicit rule.
There are three different types of implicit rules. 
.B "Pattern Matching Rules"
are searched first. If no matching pattern matching rule could be found, the
.B "Suffix Rules"
are checked and if there was no matching
suffix rule, the 
.B "Simple Suffix Rules"
are checked.
.PP
Commands defined for implicit rules of any type typically make use of the
dynamic macros
.BR $@ ,
.BR $* " and"
.B $<
as placeholders for target and dependency file names.

.SS "Pattern Matching Rules"
.PP
Pattern matching rules have been introduced by SunPRO make with SunOS-3.2
in 1986.
They are now also implemented in
.BR smake . 
Pattern matching rules are searched in the same order as they appear in the
makefile.
.PP
A pattern matching rule looks this way:
.PP
.ne 3
.RS
.HP
\f2tp\f3%\f2ts\f1\|:  \f2dp\f3%\f2ds\f1
.nf
.RI "<tab> " command
\&\|.\|.\|.
.fi
.RE
.sp
In this rule, 
.I tp
is the target prefix,
.I ts 
is the target suffix,
.I dp
is the dependency prefix
and
.I ds
is the dependency suffix.
Any of the parts may be a null string.
The 
.B %
part of the strings is the base name that matches zero or more characters
in the target name.
Whenever
.B smake
encounters a match with a target pattern of a pattern matching rule, it
uses the matching base name to construct dependency names. If the target
is out of date relative to the dependency,
.B smake
uses the commands from the pattern matching rule to build or rebuild the 
target.
.sp
A rule in the form:
.PP
.ne 3
.RS
.HP
\f2tp\f3%\f2ts\f1\|:
.nf
.RI "<tab> " command
\&\|.\|.\|.
.fi
.RE
.sp
is permitted.

.SS "Suffix Rules"
.PP
Suffix rules are the POSIX way of specifying implicit dependencies.
Suffix rules are searched when no pattern matching rule applies.
If the special target
.B .SUFFIXES:
was cleared or is empty,
.B smake
does not check suffix rules.
If
.B .SUFFIXES:
defines a list of suffixes, the current target file name is checked against
this list. If there is a match, the list of suffix rules is checked against
the target suffix and a dependency suffix that is also in the
.B .SUFFIXES:
list. The search order is derived from the order of suffixes in the suffix
list while matching dependency suffixes.
A suffix does not need to begin with a
.B '\&.'
to be recognized.
.PP
A Double Suffix rule looks this way:
.PP
.ne 3
.RS
.HP
.IB DsTs :
.nf
<tab> dependency_command
\&\|.\|.\|.
.fi
.RE
.PP
.B Ds
is the dependency suffix and
.B Ts
is the target suffix.
They are used when both target file name and dependency file name have a suffix.
Double Suffix rules are searched before Single Suffix rules are checked.
.PP
A Single Suffix rule looks this way:
.PP
.ne 3
.RS
.HP
.IB Ds :
.nf
<tab> dependency_command
\&\|.\|.\|.
.fi
.RE
.PP
.B Ds
is the dependency suffix.
Single Suffix rules are used when the target file name does not have a suffix.

.SS "Simple Suffix Rules"
.PP
Simple suffix rules have the lowest preference when looking for
implicit rules.
Simple suffix rules are specific to
.BR smake.
.PP
A simple suffix rule looks this way:
.PP
.ne 3
.RS
.HP
.I target_suffix
.B :
.IR dependency_1_suffix " .\|.\|."
.nf
<tab> dependency_1_command
\&\|.\|.\|.
.fi
.RE
.PP
The first line may not start with a TAB character.
It starts with the target suffix or "" if no target suffix exists.
The target suffix is followed by the target separator (':') and
one or more dependency suffixes which are also written as "" if
no dependency suffix exists.
The first line is followed by exactly the same number of Bourne
shell command lines (each starting with a TAB) as there were dependency
suffix specifications in the right side of the first line.
Each of the Bourne shell command lines correspond to one of the
.I dependency suffixes
in the same order.
.PP
When 
.B smake
looks for a possible source for a target with a specific suffix,
the dependency suffixes are tried out in the order they appear in the
first line of the suffix rule. If a source is found, the corresponding
command line is executed.
.PP
There may only one simple suffix rule per target suffix.
All suffixes except the empty suffix ("") must start with a dot ('.').
.PP
The following example shows how a simple suffix rule
for creating a zero suffix executable from a .o file may look:
.PP
.ne 2
.nf
.B
"": .o
.B 	$(CC) \-o $@ $<
.fi
.PP
A simple suffix rule that describes how to create a
.B \&.o
file from the possible
.BR \&.c " and " .s
sources may look this way:
.PP
.ne 3
.nf
.B \&.o: .c .s
.B 	$(CC) \-c $<
.B 	$(AS) \-o $*.o $<
.fi
.PP
If 
.B smake
is going to update 
.B foo.c
using simple suffix rules, it will first look for a file
.B foo.c
and then for a file
.BR foo.s .
If the file
.B foo.c
can be found the first command line 
.RB ( "$(CC) \-c $<" )
is executed, if the file
.B foo.s
can be found the second command line 
.RB ( "$(AS) \-o $*.o $<" )
is executed. Which command is executed depends on which 
source file exists.

.SH "DEFAULT IMPLICIT RULES"
.PP
Changing the implicit rules allows one to change the default behavior
of
.BR smake .
.SS "Default Simple Suffix Rules"
.PP
The current default implicit rules are using the simple suffix rule
notation are compiled into
.BR smake :
.PP
.nf
.BI FC= 		f77
.BI RC= 		f77
.BI PC= 		pc
.BI AS= 		as
.BI CC= 		cc
.BI LEX= 		lex
.BI YACCR= "	yacc \-r"
.BI YACC= 		yacc
.BI ROFF= 		nroff
.BI RFLAGS= 	\-ms
.B \&.o: "	.c .s .l"
.B
 	$(CC) \-c $(CFLAGS) $0
.B
 	$(AS) \-o $*.o $0
.B
 	$(LEX) $(LFLAGS) $0;$(CC) \-c $(CFLAGS) lex.yy.c;rm lex.yy.c;mv lex.yy.o $@
.B \&.c: 	.y
.B
	$(YACC) $(YFLAGS) $0;mv y.tab.c $@
.B
"":  .o .sc
.B
	$(CC) \-o $* $0
.B
	$(ROFF) $(RFLAGS) $0 > $@
.fi
.PP
If 
.B smake
reads a file
.B defaults.smk
with default implicit rules, the compiled in rules are disabled.

.SH ENVIRONMENT
On startup,
.B smake
reads all environment variables (except the
.B SHELL
environment) into make macros.
The following environment variables affect the behavior of 
.BR smake .
.TP 12
.B FORCE_SHELL
If the 
.B FORCE_SHELL
environment is present,
.B smake
behaves as if the special target
.B \&.FORCE_SHELL:
appeared in a makefile.
.TP
.B LANG
Sets up a default value for internationalization variables that are unset or NULL:
.TP
.B LC_ALL
If set, this overrides any other internationalization variables.
.TP
.B LC_CTYPE
Determine the the interpretation of byte sequences.
.TP
.B LC_MESSAGES
Determine the diagnostic messages.
.TP
.B MAKE_LEVEL
This variable is managed by
.B smake
to track nested
.B smake
calls.
It is initialized with 1 and exported. Nested calls to
.B smake
increment the level.
.TP
.B MAKEFLAGS
This variable is set up by 
.B smake
in order to forward command line options to nested calls to
.BR smake .
In order to do this,
.B smake
sets the content of the 
.B MAKEFLAGS
variable to contain a list of single character option letters.
The option 
.B \-f
is not forwarded via the
.B MAKEFLAGS
environment.
If command line macro definitions in the form
.IR name=value
have been specified, the list of option letters is followed
by the string "\ --\ " and by a list of macro definitions.
.sp
If any of the
.IR name=value
command line macro definitions contains a space ('\ ') or a 
backslash ('\e'), these characters are escaped by a single
backslash.
.sp
As required by POSIX,
.B smake
accepts all possible variants of formatting the content of the
.B MAKEFLAGS
environment.
.sp
See section
.B "Special Macros"
for more information on the
.B MAKEFLAGS
environment.
.TP
.B PATH
The
.B PATH
environment variable is used by
.B smake
when calling commands. When 
.B PATH
is modified, this may cause that specific commands cannot be found
or that a different implementation with different behavior is found 
instead.
.TP
.B PROJECTDIR
This environment variable controls the way SCCS history files are searched for.
See
.BR sccs (1)
for more information.

.SH "ASYNCHRONOUS EVENTS"
.PP
If not already ignored by the shell, 
.B smake
catches
.BR SIGHUP ,
.BR SIGINT ,
.B SIGQUIT 
and
.B SIGTERM
and removes the current target unless the current target is a directory,
the current target is a prerequisite of the special target
.B .PRECIOUS
or the special target
.B .PHONY
or one of the options: 
.BR \-t ,
.BR \-q ,
.B \-p
or
.BR \-n 
have been specified.
.PP
As 
.BR bash (1)
is known to handle signals in a non POSIX compliant way because bash
sets up different process groups for non-interactive commands, 
.B smake
actively propagates the signals named above in case that the autoconfiguration
identified /bin/sh to be bash based.

.SH "EXIT STATUS"
.PP
When the
.B \-q 
option is specified,
.B smake
exits with one of the following values:
.TP
.B 0
Successful completion.
.TP
.B 1
The target was not up-to-date.
.TP
.B -1 (255)
A command line usage error or makefile parsing error occurred. 
.TP
.B >0
An error occurred.
.PP
When the
.B \-q 
option is not specified,
.B smake
exits with one of the following values:
.TP
.B 0
Successful completion.
.TP
.B -1 (255)
A command line usage error or makefile parsing error occurred. 
.TP
.B >0
An error occurred.

.SH FILES
.PP
.TP
.B SMakefile
.TP
.B Makefile
.TP
.B makefile
.B Smake
first looks for 
.B SMakefile
then for
.B Makefile
and then for
.B makefile
in the current directory to find a list of rules to be used to resolve
the targets.
.TP
.B defaults.smk
If 
.B smake 
finds this file in the current directory, then the implicit rules
are read in from this file.
.TP
.B /opt/schily/share/lib/smake/defaults.smk
If the file
.B defaults.smk
could not be found, then 
.B smake
tries to read the implicit rules from this file.
If this file cannot be found too, then 
.B smake uses the rules compiled into
.BR smake .

.SH "SEE ALSO"
.BR dmake (1),
.BR make (1s),
.BR sh (1),
.BR sccs (1),
.BR sysctl (2),
.BR sysinfo (2),
.BR uname (2),
.BR makefiles (5),
.BR makerules (5)

.SH NOTES
.PP
If a platform uses a shell that does not handle signals correctly and
.B smake
does not implement the work around that was mentioned above in the section
.BR "ASYNCHRONOUS EVENTS" ,
sub makes may continue to run even though the top level make was killed by
a signal.
.PP
In order to be able to abort complex make structures after a failed
command was encountered, the shell needs to behave correctly with the 
.B \-e
option.
Bash version 3.x in general and the Korn Shell variant that comes with HP-UX 
are known to handle the
.B \-e
option in a non-POSIX compliant way.
If the autoconfiguration tests detect a non-compliant /bin/sh and there is 
a working Bourne Shell available under /bin/bosh or /opt/schily/bin/bosh,
.B smake
will use this
.B bosh
as the default shell.  See the schily source consolidation at:
https://sourceforge.net/projects/schilytools/files/
.PP
The old 
.B schily (SING)
makefile system (until late 1999) did only define simple suffix rules.
The current version of
.B smake
added support for pattern matching rules and POSIX suffix rules.
These rules are considered to be rated with higher preference than
simple suffix rules.
If build in suffix rules can be found, current 
.B smake
versions will not work correctly with old makefile systems.
To use current 
.B smake
versions with old makefile systems, call
.B smake
with the 
.B \-r
flag to disable build in POSIX suffix rules.
Newer makefile system version include pattern matching rules that will be
searched before the POSIX suffix rules.
.PP
A new shell is run for each command line. If you want to run
more complicated shell scripts, you need to escape the end of line
with a backslash to keep all commands on one virtual shell command line.
.PP
.B Smake
tries to be as
.B POSIX
compliant as possible.
.PP
.B POSIX
does not cover everything that is needed to write portable makefiles
suitable to compile large portable projects.
Even simple things like
.BI macro+= value
are not covered by
.BR POSIX .
Note that adding something to a macro definition is supported by all
known 
.I make
implementations since ~ 1980.
In addition,
it is most unlikely
that different 
.B make
implementations although
.B POSIX
compliant, are compatible enough to maintain large projects.
For these reasons, it seems to be better to have a portable 
.B make 
implementation like
.BR smake .

.SH BUGS
.PP
.B SCCS
retrieval is not yet implemented.
.PP
A command line that contains the macro
.B "$(MAKE)"
is always executed, even when in POSIX mode.
This is an intended conflict with the POSIX standard since POSIX.1-2008.
.PP
Built in library handling is not yet implemented.
.PP
There are currently no other known bugs.
As 
.B smake
since spring 1993 is used as the reference make program for
the SCHILY (Sing) makefile system,
.B smake
is the best choice when compiling projects that are using
the SCHILY (Sing) makefile system.

Mail other bugs and suggestions to
.B schilytools@mlists.in-berlin.de
or open a ticket at
.BR https://codeberg.org/schilytools/schilytools/issues .
.PP
The mailing list archive may be found at:
.PP
.nf
.BR https://mlists.in-berlin.de/mailman/listinfo/schilytools-mlists.in-berlin.de .
.fi

.SH AUTHOR
J\*org Schilling and the schilytools project authors.

.SH "SOURCE DOWNLOAD"
The source code for
.B smake
is included in the
.B schilytools
project and may be retrieved from the
.B schilytools
project at Codeberg at
.LP
.BR https://codeberg.org/schilytools/schilytools .
.LP
The download directory is
.LP
.BR https://codeberg.org/schilytools/schilytools/releases .
